
                    You are an expert assistant specializing in Solidity fuzzing with a deep understanding of SWC and DASP vulnerabilities. 
                    Your objective is to generate a diverse set of transactions and inputs targeting the main EVM/Solidity vulnerabilities.
                    Respond strictly in JSON format, following the provided instructions without any additional text.
                

                
                    ### Is this contract vulnerable to any of Ether Leak, Block State Dependency, Integer underflow/overflow, Mishandled Exception, Reentrancy?
                        (Think step-by-step, write seeds that demonstrates the actual attack vector against this contract and only use contract ABI functions)
                        Do not call private/internal functions directly, when ETH is sent to the contract, use fallback functions that handle incoming funds.                
                        
                        pragma solidity ^0.4.0; contract LuckyDoubler { address private owner; uint private balance = 0; uint private fee = 5; uint private multiplier = 125; mapping (address => User) private users; Entry[] private entries; uint[] private unpaidEntries; function LuckyDoubler() { owner = msg.sender; } modifier onlyowner { if (msg.sender == owner) _; } struct User { address id; uint deposits; uint payoutsReceived; } struct Entry { address entryAddress; uint deposit; uint payout; bool paid; } function() payable { init(); } function init() private{ if (msg.value < 1 ether) { msg.sender.send(msg.value); return; } join(); } function join() private { uint dValue = 1 ether; if (msg.value > 1 ether) { msg.sender.send(msg.value - 1 ether); dValue = 1 ether; } if (users[msg.sender].id == address(0)) { users[msg.sender].id = msg.sender; users[msg.sender].deposits = 0; users[msg.sender].payoutsReceived = 0; } entries.push(Entry(msg.sender, dValue, (dValue * (multiplier) / 100), false)); users[msg.sender].deposits++; unpaidEntries.push(entries.length -1); balance += (dValue * (100 - fee)) / 100; uint index = unpaidEntries.length > 1 ? rand(unpaidEntries.length) : 0; Entry theEntry = entries[unpaidEntries[index]]; if (balance > theEntry.payout) { uint payout = theEntry.payout; theEntry.entryAddress.send(payout); theEntry.paid = true; users[theEntry.entryAddress].payoutsReceived++; balance -= payout; if (index < unpaidEntries.length - 1) unpaidEntries[index] = unpaidEntries[unpaidEntries.length - 1]; unpaidEntries.length--; } uint fees = this.balance - balance; if (fees > 0) { owner.send(fees); } } uint256 constant private FACTOR = 1157920892373161954235709850086879078532699846656405640394575840079131296399; function rand(uint max) constant private returns (uint256 result){ uint256 factor = FACTOR * 100 / max; uint256 lastBlockNumber = block.number - 1; uint256 hashVal = uint256(block.blockhash(lastBlockNumber)); return uint256((uint256(hashVal) / factor)) % max; } function changeOwner(address newOwner) onlyowner { owner = newOwner; } function changeMultiplier(uint multi) onlyowner { if (multi < 110 || multi > 150) throw; multiplier = multi; } function changeFee(uint newFee) onlyowner { if (fee > 5) throw; fee = newFee; } function multiplierFactor() constant returns (uint factor, string info) { factor = multiplier; info = 'The current multiplier applied to all deposits. Min 110%, max 150%.'; } function currentFee() constant returns (uint feePercentage, string info) { feePercentage = fee; info = 'The fee percentage applied to all deposits. It can change to speed payouts (max 5%).'; } function totalEntries() constant returns (uint count, string info) { count = entries.length; info = 'The number of deposits.'; } function userStats(address user) constant returns (uint deposits, uint payouts, string info) { if (users[user].id != address(0x0)) { deposits = users[user].deposits; payouts = users[user].payoutsReceived; info = 'Users stats: total deposits, payouts received.'; } } function entryDetails(uint index) constant returns (address user, uint payout, bool paid, string info) { if (index < entries.length) { user = entries[index].entryAddress; payout = entries[index].payout / 1 finney; paid = entries[index].paid; info = 'Entry info: user address, expected payout in Finneys, payout status.'; } } }                        
                

                    ### You have four sender contracts: SmartianAgent1, SmartianAgent2, SmartianAgent3, and SmartianAgent4. Use their names in the parameters that need an address and in From fields as needed.
                

                    ### Available Contract Functions (You must only use the functions in this list for Test Case Generation):

                    multiplierFactor()
changeFee(uint256) onlyowner
totalEntries()
userStats(address)
changeOwner(address) onlyowner
changeMultiplier(uint256) onlyowner
currentFee()
entryDetails(uint256)
constructor()
fallback()
                

                    ### JSON Grammar for EVM Test Case

                    #### Root
                    - An array of `TestCase` objects.

                    #### TestCase
                    - **DeployTx**: An object representing the deployment transaction, using the constructor function.
                    - **Txs**: An array of transaction (`Tx`) objects.

                    #### DeployTx
                    - **From**: A string representing the deployer's name or address.
                    - **Value**: A string representing the amount of Ether sent with the transaction.
                    - **Function**: A string representing the constructor function name being called.
                    - **Params** (optional): An array representing the parameters passed to the constructor, if it exists.
                    - **Timestamp**: A string representing the timestamp of the transaction.
                    - **Blocknum**: A string representing the block number when the transaction was included.

                    #### Tx (Transaction)
                    - **From**: A string representing the sender's name.
                    - **Value**: A string representing the amount of Ether sent with the transaction, if function is payable.
                    - **Function**: A string representing the function name being called.
                    - **Params** (optional): An array representing the parameters passed to the function.
                    - Parameters can be nested arrays.
                    - **Timestamp**: A string representing the timestamp of the transaction.
                    - **Blocknum**: A string representing the block number when the transaction was included.
                

### Example 
```json
[
    {
        "TestCase": {
            "DeployTx": {
                "From": "SmartianAgent1",
                "Value": "0",
                "Function": "constructor",
                "Params": [],
                "Timestamp": "10000000",
                "Blocknum": "20000000"
            },
            "Txs": [
                {
                    "From": "SmartianAgent1",
                    "Value": "0",
                    "Function": "caddress",
                    "Timestamp": "10000141",
                    "Blocknum": "20000198"
                },
                {
                    "From": "SmartianAgent1",
                    "Value": "0",
                    "Function": "from",
                    "Params": [
                        "SmartianAgent2"
                    ],
                    "Timestamp": "10000151",
                    "Blocknum": "20000144"
                },
                {
                    "From": "SmartianAgent2",
                    "Value": "1",
                    "Function": "transfer",
                    "Params": [
                        [
                            "0x0000000000000000000000000000000000000001"
                        ],
                        [
                            "1"
                        ]
                    ],
                    "Timestamp": "10000161",
                    "Blocknum": "20000150"
                },
                {
                    "From": "SmartianAgent1",
                    "Value": "0",
                    "Function": "from",
                    "Params": [
                        "0x0000000000000000000000000000000000000002"
                    ],
                    "Timestamp": "10000171",
                    "Blocknum": "20000156"
                },
                {
                    "From": "SmartianAgent4",
                    "Value": "2",
                    "Function": "transfer",
                    "Params": [
                        [
                            "0x0000000000000000000000000000000000000001",
                            "0x0000000000000000000000000000000000000002"
                        ],
                        [
                            "2",
                            "3"
                        ]
                    ],
                    "Timestamp": "10000181",
                    "Blocknum": "20000162"
                }
            ]
        }
    }
]
```

                
                    ### Notes
                    - Each `TestCase` contains a `DeployTx` object and an array of `Tx` objects.
                    - Each transaction (`Tx`) includes details such as sender (`From`), value (`Value`), function name (`Function`), optional parameters (`Params`), timestamp (`Timestamp`), and block number (`Blocknum`).
                    - Parameters (`Params`) can be nested arrays to accommodate functions requiring multiple lists of parameters.
                    - Do not call internal functions directly.
                    
                    ### Objective
                    Create 10 new test case objects, each containing more than 8 transactions that might uncover bugs in the contract.
                    Ensure the transactions use raw values and respect the data types in the function signatures and consider functions modifiers in your transactions.
                    Provide the response as RFC8259 compliant JSON without explanations.
                